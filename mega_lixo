	 &
	 |
	 >
	 <
	ls <|> (erro |)
	ls >| (erro newline)
	sada <> adasd (tudo ok)
	sada <>| (erro token |)
	<& (erro &)
	ls ><| (erro token <)
	le >  < (erro token <)
	ls ><   | (erro token <)
	ls >   <| (erro  token <)
	>| sadda (tudo ok)
	asdas || >> sDS
	 < &
	<>< erro de token <
	dawd >> erro de newline
	dasd << erro de newline

	echo "" "" tem que aparecer as aspas todas
	adhwih < erro newline
	sa " << da"

	rui testes
	ls || '"
	ls || (re||re))
	<< re
	ls || (((re||re) ||re)||re)
	ls || (re||re)|(re||re)
	ls || (re||re)(re
	((ls||re)||re)
	(re||re&& )
	(re||re&&(re||Re))
	ls || ((re||re)||re))
	ls << re | escreves pipe no input do pipe
	ls || escreves pipe no input do pipe
		ls || (re||re
> ||(
> re||re
> )
> )

V  errors on cd do not appear
V  >|
V  syntax errors are in printfs
V  cd + export
V  errors not appearing for cd
V  free the info in the all_data_to_solver function in out_setup_general
V  words get separated inside aspas on export var="fsajgaf akdas"
V  leaks on heredocs from env_list
V  heredoc with "" ''
V  cat < README*
V  export um=1 123 dois=2 || env
V  << *
V  ~
V  unset all vars and run export
V  cd with redirects
V  command /ls error should be of no directory
V  exit with numbers in front not ais not a
V  echo hello world
V  $? -> $?
V  unst HOME
V  ls     *
V  change readline to a fork
V  heredocs define heredoc wrong
V  ls |	|
V  (asdsaas || sdsad) || merdaa || echo gaita
V  (asdsaas || sdsad) || merdaa | cat < lol || echo gaita
V  review signals
V  turn the first line out of fork
V  << re >>> and then new 
V  (asdsaas || sdsad)
V  (dasa)
V  ls *"'aosdahas'"
V  SHLVL
V  echo "> >> < * ? [ ] | ; [ ] || && ( ) & # $  <<"
V  return int with position of input/output in the functions define_input and define_output in case of error
V  problema da dupla impressao de erro vem da contagem de inputs antes do programa normal
V  $_ fazer dentro de forks

execve errors
organize files
leak on shlvl change